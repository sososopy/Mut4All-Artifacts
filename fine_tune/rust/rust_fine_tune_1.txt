Mutation Operator: Inject Const Generic Parameters Into Functions Target: - Free functions (non-main) and trait/impl methods. 
Mutation Rule: 
1. Traverse all function definitions (`fn`) in the Rust source file, including both standalone functions and functions inside `impl` blocks. 
2. Skip any function named `main`.
3. For each matched function, inject four constant generic parameters into its signature: - `const N: usize` - `const M: isize` - `const B: bool` - `const C: char`
4. This transformation extends the generic parameter list of each function, making use of const generics across different types
Example Before Mutation:
fn foo() {} impl MyStruct { fn bar(&self) {} }
Example After Mutation:
fn foo<const N: usize, const M: isize, const B: bool, const C: char>() {} impl MyStruct { fn bar<const N: usize, const M: isize, const B: bool, const C: char>(&self) {} }
Explanation: This mutation operator adds multiple const generic parameters (usize, isize, bool, char) to function definitions that are not named main. It specifically targets both free-standing functions and methods in impl blocks. The inclusion of diverse const generic types increases the complexity of monomorphization and trait resolution logic within the compiler. By injecting edge-case const types like bool and char, which are historically more error-prone in const generics, this mutation is likely to expose internal compiler inconsistencies or misbehavior, especially in less-tested generic interactions. The transformation maintains program structure while significantly increasing the chance of hitting edge cases in the compiler's type and code generation subsystems.
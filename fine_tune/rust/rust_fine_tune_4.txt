Mutation Operator: Insert Self Invocation Target: - Free functions (excluding `main`) - Methods inside `impl` blocks (excluding methods named `main`) 
Mutation Rule: 
1. Traverse all function definitions in the Rust source file, including both free functions and methods inside `impl` blocks. 
2. Skip any function named `main`. 
3. For each matched function or method: Extract the function's name and parameters. Create a function call expression that invokes the same function using its own parameters as arguments. If a parameter pattern is not a simple identifier, use a placeholder identifier (e.g., `dummy`) in the call. 
4. Insert this function call expression as the "first statement" in the function body. 
Example Before Mutation: 
fn greet(name: String) { println!(\"Hello, {}\", name); } impl Greeter { fn greet(&self, msg: String) { println!(\"{}\", msg); } } 
Example After Mutation: 
fn greet(name: String) { greet(name.clone()); println!(\"Hello, {}\", name); } impl Greeter { fn greet(&self, msg: String) { greet(msg.clone()); println!(\"{}\", msg); } } 
Explanation: This mutation operator inserts a call to the current function itself as the first statement within its own body. It reuses the function's original parameters as arguments in the self-invocation. The goal is to trigger infinite recursion or unexpected behavior during execution or compilation, which can expose flaws in the compiler's handling of recursion, borrow checking, type inference, and function resolution. Inserting such self-invocations is particularly useful for testing the compiler's robustness in dealing with cyclic execution paths, early call evaluation, and potential stack overflows.
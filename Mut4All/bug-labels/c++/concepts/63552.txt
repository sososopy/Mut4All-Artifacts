Issue Title:
[C++] [Concepts] Using "constrained auto syntax" with a concept that takes template template parameters causes a crash

Source Code & Bug Trace:
// It crashes!
#include <iostream>

template <typename T, template <class> typename Op>
concept InvocableWith777 = std::is_invocable_v<Op<void>, decltype(777), T>;

void addTo777Show(InvocableWith777<std::plus> auto x) {
  std::cout << 777 + x << std::endl;
}

int main() { addTo777Show(223); }

void f(C auto x) {}

â¯ clang++ -S -emit-llvm -Xclang -disable-llvm-passes -std=c++20 test.cpp
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace, preprocessed source, and associated run script.
Stack dump:
0.      Program arguments: clang++ -S -emit-llvm -Xclang -disable-llvm-passes -std=c++20 test.cpp
1.      test.cpp:6:53: current parser token ')'
 #0 0x00007f3f82b7baaa (/usr/lib/libLLVM-15.so+0xd7baaa)
 #1 0x00007f3f82b7913f llvm::sys::RunSignalHandlers() (/usr/lib/libLLVM-15.so+0xd7913f)
 #2 0x00007f3f82a5c4a9 (/usr/lib/libLLVM-15.so+0xc5c4a9)
 #3 0x00007f3f8184fab0 (/usr/lib/libc.so.6+0x39ab0)
 #4 0x00007f3f82a7c6a5 llvm::FoldingSetBase::InsertNode(llvm::FoldingSetBase::Node*, void*, llvm::FoldingSetBase::FoldingSetInfo const&) (/usr/lib/libLLVM-15.so+0xc7c6a5)
 #5 0x00007f3f8a12d1ee clang::ASTContext::getAutoTypeInternal(clang::QualType, clang::AutoTypeKeyword, bool, bool, clang::ConceptDecl*, llvm::ArrayRef<clang::TemplateArgument>, bool) const (/usr/lib/libclang-cpp.so.15+0x92d1ee)
 #6 0x00007f3f8bdb7b9a (/usr/lib/libclang-cpp.so.15+0x25b7b9a)
 #7 0x00007f3f8ad22f68 clang::Sema::GetTypeForDeclarator(clang::Declarator&, clang::Scope*) (/usr/lib/libclang-cpp.so.15+0x1522f68)
 #8 0x00007f3f8a858339 clang::Sema::ActOnParamDeclarator(clang::Scope*, clang::Declarator&) (/usr/lib/libclang-cpp.so.15+0x1058339)
 #9 0x00007f3f8a080cec (/usr/lib/libclang-cpp.so.15+0x880cec)
#10 0x00007f3f8a082755 clang::Parser::ParseFunctionDeclarator(clang::Declarator&, clang::ParsedAttributes&, clang::BalancedDelimiterTracker&, bool, bool) (/usr/lib/libclang-cpp.so.15+0x882755)
#11 0x00007f3f8a083922 clang::Parser::ParseDirectDeclarator(clang::Declarator&) (/usr/lib/libclang-cpp.so.15+0x883922)
#12 0x00007f3f8a073b8f clang::Parser::ParseDeclaratorInternal(clang::Declarator&, void (clang::Parser::*)(clang::Declarator&)) (/usr/lib/libclang-cpp.so.15+0x873b8f)
#13 0x00007f3f8a7173a1 clang::Sema::runWithSufficientStackSpace(clang::SourceLocation, llvm::function_ref<void ()>) (/usr/lib/libclang-cpp.so.15+0xf173a1)
#14 0x00007f3f8a06ee7f clang::Parser::ParseDeclGroup(clang::ParsingDeclSpec&, clang::DeclaratorContext, clang::ParsedAttributes&, clang::SourceLocation*, clang::Parser::ForRangeInit*) (/usr/lib/libclang-cpp.so.15+0x86ee7f)
#15 0x00007f3f8a0e9f39 (/usr/lib/libclang-cpp.so.15+0x8e9f39)
#16 0x00007f3f8a0ff65d clang::Parser::ParseExternalDeclaration(clang::ParsedAttributes&, clang::ParsingDeclSpec*) (/usr/lib/libclang-cpp.so.15+0x8ff65d)
#17 0x00007f3f8a0ff916 clang::Parser::ParseTopLevelDecl(clang::OpaquePtr<clang::DeclGroupRef>&, clang::Sema::ModuleImportState&) (/usr/lib/libclang-cpp.so.15+0x8ff916)
#18 0x00007f3f8a04c3c9 clang::ParseAST(clang::Sema&, bool, bool) (/usr/lib/libclang-cpp.so.15+0x84c3c9)
#19 0x00007f3f8b6c8789 clang::FrontendAction::Execute() (/usr/lib/libclang-cpp.so.15+0x1ec8789)
#20 0x00007f3f8b66c7ff clang::CompilerInstance::ExecuteAction(clang::FrontendAction&) (/usr/lib/libclang-cpp.so.15+0x1e6c7ff)
#21 0x00007f3f8b72d59a clang::ExecuteCompilerInvocation(clang::CompilerInstance*) (/usr/lib/libclang-cpp.so.15+0x1f2d59a)
#22 0x000056130e2c9027 cc1_main(llvm::ArrayRef<char const*>, char const*, void*) (/usr/bin/clang-15+0x13027)
#23 0x000056130e2ccda7 (/usr/bin/clang-15+0x16da7)
#24 0x00007f3f8b3dc0c9 (/usr/lib/libclang-cpp.so.15+0x1bdc0c9)
#25 0x00007f3f82a5c577 llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) (/usr/lib/libLLVM-15.so+0xc5c577)
#26 0x00007f3f8b3dfd74 (/usr/lib/libclang-cpp.so.15+0x1bdfd74)
#27 0x00007f3f8b3bd0fe clang::driver::Compilation::ExecuteCommand(clang::driver::Command const&, clang::driver::Command const*&, bool) const (/usr/lib/libclang-cpp.so.15+0x1bbd0fe)
#28 0x00007f3f8b3bd4bd clang::driver::Compilation::ExecuteJobs(clang::driver::JobList const&, llvm::SmallVectorImpl<std::pair<int, clang::driver::Command const*>>&, bool) const (/usr/lib/libclang-cpp.so.15+0x1bbd4bd)
#29 0x00007f3f8b3c7d6c clang::driver::Driver::ExecuteCompilation(clang::driver::Compilation&, llvm::SmallVectorImpl<std::pair<int, clang::driver::Command const*>>&) (/usr/lib/libclang-cpp.so.15+0x1bc7d6c)
#30 0x000056130e2cf1f1 clang_main(int, char**) (/usr/bin/clang-15+0x191f1)
#31 0x00007f3f81839850 (/usr/lib/libc.so.6+0x23850)
#32 0x00007f3f8183990a __libc_start_main (/usr/lib/libc.so.6+0x2390a)
#33 0x000056130e2c2ea5 _start (/usr/bin/clang-15+0xcea5)
clang-15: error: clang frontend command failed with exit code 139 (use -v to see invocation)
clang version 15.0.7
Target: x86_64-pc-linux-gnu
Thread model: posix
InstalledDir: /usr/bin
clang-15: note: diagnostic msg: 
********************

PLEASE ATTACH THE FOLLOWING FILES TO THE BUG REPORT:
Preprocessed source(s) and associated run script(s) are located at:
clang-15: note: diagnostic msg: /tmp/test-da007e.cpp
clang-15: note: diagnostic msg: /tmp/test-da007e.sh
clang-15: note: diagnostic msg: 

********************


// (1) declare a type parameter T with a concept constraint
template <InvocableWith777<std::plus> T>
void addTo777Show(T x) {
  std::cout << 777 + x << std::endl;
}

// (2) declare a type parameter T, and use "requires" clause
template <typename T>
  requires InvocableWith777<T, std::plus>
void addTo777Show(T x) {
  std::cout << 777 + x << std::endl;
}

// (3) fix a concept. takes an ordinary type parameter instead of a template template parameter
template <typename T, typename Op>
concept InvocableWith777 = std::is_invocable_v<Op, decltype(777), T>;

void addTo777Show(InvocableWith777<std::plus<void>> auto x) {
  std::cout << 777 + x << std::endl;
}

// (4) Again, it crashes
void addTo777Show(InvocableWith777<std::plus> auto x) {
  std::cout << 777 + x << std::endl;
}

g++ -std=c++20 test.cpp && ./a.out

Bug Labels:
c++20, clang:frontend, concepts, crash
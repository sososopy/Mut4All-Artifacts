Issue Title:
ICE: `cargo check` panics on toolchain `stable-x86_64-unknown-linux-gnu` · Issue #125160 · rust-lang/rust · GitHub

Rust Code:
use std::process::ExitCode;

use ansi_term::Color;
use ast::{expr::{AsReferenceExpr, AssignmentExpr, BinaryExpr, BinaryOp, CallExpr, Expr, LiteralExpr, ReturnExpr}, typing::{PrimType, Type, TypeBits}, Block, Collection, Decl, FunctionDecl, Identifier, IntLit, Loc, NamespaceDecl, Prototype};
use check::Checker;

mod ast;
mod check;

fn main() -> ExitCode {
    let mut collection = Collection::new();
    let main_name = collection.add("main".to_string());
    let other_func_name = collection.add("other_func".to_string());
    let my_slot_name = collection.add("my_slot".to_string());
    let my_namespace_name = collection.add("mynamespace".to_string());
    let loc = Loc::new(0, 0, 0);
    let global = &[
        Decl::NamespaceDecl(NamespaceDecl::new(
            loc.clone(),
            Identifier(
                loc.clone(),
                my_namespace_name
            ),
            loc.clone(),
            vec![
                Decl::NamespaceDecl(NamespaceDecl::new(
                    loc.clone(),
                    Identifier(
                        loc.clone(),
                        my_namespace_name
                    ),
                    loc.clone(),
                    vec![
                        Decl::FunctionDecl(FunctionDecl::new(
                            vec![],
                            loc.clone(),
                            Prototype::new(
                                Identifier(loc.clone(), main_name),
                                loc.clone(),
                                vec![],
                                loc.clone(),
                                Box::new(Type::new_primitive(
                                    loc.clone(),
                                    PrimType::new_int(TypeBits::B64)
                                )),
                                false,
                            ),
                            Block::new(
                                loc.clone(),
                                vec![
                                    Expr::SlotDecl(
                                        Identifier(loc.clone(), my_slot_name),
                                        Type::Primitive {
                                            loc: loc.clone(),
                                            ty: PrimType::Int(TypeBits::B64),
                                        }
                                    ),
                                    Expr::Assignment(
                                        AssignmentExpr(BinaryExpr {
                                            left_hand_side: Box::new(Expr::AsReference(
                                                AsReferenceExpr(loc.clone(), Box::new(
                                                    Expr::Variable(Identifier(loc.clone(), my_slot_name))
                                                ))
                                            )),
                                            op: (loc.clone(), BinaryOp::Plus),
                                            right_hand_side: Box::new(Expr::Literal(LiteralExpr::Int(
                                                IntLit(loc.clone(), 420)
                                            )))
                                        })
                                    ),
                                    Expr::Call(
                                        CallExpr::new(
                                            Box::new(
                                                Expr::Variable(Identifier(loc.clone(), main_name)),
                                            ),
                                            vec![]
                                        )
                                    ),
                                    Expr::Return(ReturnExpr {
                                        ret_kw: loc.clone(),
                                        expr: Some(Box::new(
                                            Expr::Variable(Identifier(loc.clone(), my_slot_name)),
                                        )),
                                    }),
                                    // Expr::Return(ReturnExpr {
                                    //     ret_kw: loc.clone(),
                                    //     expr: None,
                                    // }),
                                ],
                                loc.clone(),
                            )
                        ))
                    ],
                    loc.clone()
                )),
            ],
            loc.clone()
        )),
    ];
    let mut checker = Checker::new(collection);
    checker.collect(global);

    let hir_decls = checker.pass_program(global);

    let errors = checker.errors();
    let warnings = checker.warnings();

    let report = || {
        for error in errors {
            eprintln!("{}", error.to_string(checker.collection()))
        }
        for warning in warnings {
            eprintln!("{}", warning.to_string(checker.collection(), true))
        }
        eprintln!("{:#?}", hir_decls);
        if !errors.is_empty() {
            // fail if any error occurred
            eprintln!(
                "Compilation {} with {} error{} and {} warning{}",
                Color::Red.bold().paint("FAILED"),
                errors.len(),
                if errors.len() == 1 {
                    ""
                } else {
                    "s"
                },
                warnings.len(),
                if warnings.len() == 1 {
                    ""
                } else {
                    "s"
                },
            );
    
            ExitCode::FAILURE
        } else {
            // okay otherwise
            eprintln!(
                "Compilation {} with {} error{} and {} warning{}",
                Color::Green.bold().paint("SUCCESS"),
                errors.len(),
                if errors.len() == 1 {
                    ""
                } else {
                    "s"
                },
                warnings.len(),
                if warnings.len() == 1 {
                    ""
                } else {
                    "s"
                },
            );
    
            ExitCode::SUCCESS
        }
    };

    report()
}

Bug Trace:
0:     0x7f9000ba5d16 - std::backtrace_rs::backtrace::libunwind::trace::h6e4a662bea54ccfc
                               at /rustc/7cf61ebde7b22796c69757901dd346d0fe70bd97/library/std/src/../../backtrace/src/backtrace/libunwind.rs:104:5
   1:     0x7f9000ba5d16 - std::backtrace_rs::backtrace::trace_unsynchronized::hb42b4eb2797d9c0e
                               at /rustc/7cf61ebde7b22796c69757901dd346d0fe70bd97/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5
   2:     0x7f9000ba5d16 - std::sys_common::backtrace::_print_fmt::h2bc261f3223f4e4d
                               at /rustc/7cf61ebde7b22796c69757901dd346d0fe70bd97/library/std/src/sys_common/backtrace.rs:68:5
   3:     0x7f9000ba5d16 - <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt::h9cca0343d66d16a8
                               at /rustc/7cf61ebde7b22796c69757901dd346d0fe70bd97/library/std/src/sys_common/backtrace.rs:44:22
   4:     0x7f9000bf8770 - core::fmt::rt::Argument::fmt::h8b666c45176be671
                               at /rustc/7cf61ebde7b22796c69757901dd346d0fe70bd97/library/core/src/fmt/rt.rs:142:9
   5:     0x7f9000bf8770 - core::fmt::write::h4311bce0ee536615
                               at /rustc/7cf61ebde7b22796c69757901dd346d0fe70bd97/library/core/src/fmt/mod.rs:1120:17
   6:     0x7f9000b9958f - std::io::Write::write_fmt::h0685c51539d0a0cd
                               at /rustc/7cf61ebde7b22796c69757901dd346d0fe70bd97/library/std/src/io/mod.rs:1846:15
   7:     0x7f9000ba5af4 - std::sys_common::backtrace::_print::h25f19b1d64e81f86
                               at /rustc/7cf61ebde7b22796c69757901dd346d0fe70bd97/library/std/src/sys_common/backtrace.rs:47:5
   8:     0x7f9000ba5af4 - std::sys_common::backtrace::print::h2fb8f70628a241ed
                               at /rustc/7cf61ebde7b22796c69757901dd346d0fe70bd97/library/std/src/sys_common/backtrace.rs:34:9
   9:     0x7f9000ba8887 - std::panicking::default_hook::{{closure}}::h05093fe2e3ef454d
  10:     0x7f9000ba85e9 - std::panicking::default_hook::h5ac38aa38e0086d2
                               at /rustc/7cf61ebde7b22796c69757901dd346d0fe70bd97/library/std/src/panicking.rs:292:9
  11:     0x7f8ffd9ab4dc - std[6985fe5dee7179c0]::panicking::update_hook::<alloc[c678e180b9908eaa]::boxed::Box<rustc_driver_impl[57d634a88fe18246]::install_ice_hook::{closure#0}>>::{closure#0}
  12:     0x7f9000ba8fd6 - <alloc::boxed::Box<F,A> as core::ops::function::Fn<Args>>::call::hce488f674cf5618d
                               at /rustc/7cf61ebde7b22796c69757901dd346d0fe70bd97/library/alloc/src/boxed.rs:2029:9
  13:     0x7f9000ba8fd6 - std::panicking::rust_panic_with_hook::hed79743dc8b4b969
                               at /rustc/7cf61ebde7b22796c69757901dd346d0fe70bd97/library/std/src/panicking.rs:785:13
  14:     0x7f9000ba8ce9 - std::panicking::begin_panic_handler::{{closure}}::ha437b5d58f431abf
                               at /rustc/7cf61ebde7b22796c69757901dd346d0fe70bd97/library/std/src/panicking.rs:651:13
  15:     0x7f9000ba6216 - std::sys_common::backtrace::__rust_end_short_backtrace::hd98e82d5b39ec859
                               at /rustc/7cf61ebde7b22796c69757901dd346d0fe70bd97/library/std/src/sys_common/backtrace.rs:171:18
  16:     0x7f9000ba8a74 - rust_begin_unwind
                               at /rustc/7cf61ebde7b22796c69757901dd346d0fe70bd97/library/std/src/panicking.rs:647:5
  17:     0x7f9000bf4e75 - core::panicking::panic_fmt::hc69c4d258fe11477
                               at /rustc/7cf61ebde7b22796c69757901dd346d0fe70bd97/library/core/src/panicking.rs:72:14
  18:     0x7f9000be5daf - alloc::raw_vec::capacity_overflow::h2434c0983b86c347
                               at /rustc/7cf61ebde7b22796c69757901dd346d0fe70bd97/library/alloc/src/raw_vec.rs:570:5
  19:     0x7f8fffbf6db9 - rustc_incremental[61856d840af4295e]::persist::load::setup_dep_graph
  20:     0x7f8fffb4536e - <rustc_interface[be390c89f505a55d]::queries::Queries>::global_ctxt
  21:     0x7f8fffa8ccee - rustc_interface[be390c89f505a55d]::interface::run_compiler::<core[a93eb12aade15298]::result::Result<(), rustc_span[e4948e3682155d21]::ErrorGuaranteed>, rustc_driver_impl[57d634a88fe18246]::run_compiler::{closure#0}>::{closure#0}
  22:     0x7f8fffb34a1f - std[6985fe5dee7179c0]::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface[be390c89f505a55d]::util::run_in_thread_with_globals<rustc_interface[be390c89f505a55d]::interface::run_compiler<core[a93eb12aade15298]::result::Result<(), rustc_span[e4948e3682155d21]::ErrorGuaranteed>, rustc_driver_impl[57d634a88fe18246]::run_compiler::{closure#0}>::{closure#0}, core[a93eb12aade15298]::result::Result<(), rustc_span[e4948e3682155d21]::ErrorGuaranteed>>::{closure#0}::{closure#0}, core[a93eb12aade15298]::result::Result<(), rustc_span[e4948e3682155d21]::ErrorGuaranteed>>
  23:     0x7f8fffb3487d - <<std[6985fe5dee7179c0]::thread::Builder>::spawn_unchecked_<rustc_interface[be390c89f505a55d]::util::run_in_thread_with_globals<rustc_interface[be390c89f505a55d]::interface::run_compiler<core[a93eb12aade15298]::result::Result<(), rustc_span[e4948e3682155d21]::ErrorGuaranteed>, rustc_driver_impl[57d634a88fe18246]::run_compiler::{closure#0}>::{closure#0}, core[a93eb12aade15298]::result::Result<(), rustc_span[e4948e3682155d21]::ErrorGuaranteed>>::{closure#0}::{closure#0}, core[a93eb12aade15298]::result::Result<(), rustc_span[e4948e3682155d21]::ErrorGuaranteed>>::{closure#1} as core[a93eb12aade15298]::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}
  24:     0x7f9000bb2675 - <alloc::boxed::Box<F,A> as core::ops::function::FnOnce<Args>>::call_once::h32ae492e80523c39
                               at /rustc/7cf61ebde7b22796c69757901dd346d0fe70bd97/library/alloc/src/boxed.rs:2015:9
  25:     0x7f9000bb2675 - <alloc::boxed::Box<F,A> as core::ops::function::FnOnce<Args>>::call_once::hd05b2dc112b7a972
                               at /rustc/7cf61ebde7b22796c69757901dd346d0fe70bd97/library/alloc/src/boxed.rs:2015:9
  26:     0x7f9000bb2675 - std::sys::pal::unix::thread::Thread::new::thread_start::h40e6fd3f8ce15a14
                               at /rustc/7cf61ebde7b22796c69757901dd346d0fe70bd97/library/std/src/sys/pal/unix/thread.rs:108:17
  27:     0x7f8ffaa92bb2 - start_thread
  28:     0x7f8ffab1400c - clone3
  29:                0x0 - <unknown>

Bug Labels:
A-incr-comp, C-bug, I-ICE, T-compiler

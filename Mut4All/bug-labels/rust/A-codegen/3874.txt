Issue Title:
ref pattern nested inside let LHS causes LLVM assertion failure · Issue #3874 · rust-lang/rust · GitHub

Rust Code:
$ cat ./experiment.rs

enum PureCounter { PureCounter(uint) }

impl PureCounter : iter::BaseIter<uint> {
    pure fn each(blk: fn(v: &uint) -> bool) {
        let PureCounter(ref x) = self;
        match blk(x) {
          true => PureCounter( (*x) + 1 ).each(blk),
          false => ()
        }
    }

    pure fn size_hint() -> Option<uint> { None }
}

fn main() {
    do PureCounter(0).each |nbox| {
        io::println( (*nbox).to_str() );
        (*nbox) < 5
    }
}

$ rustc ./experiment.rs
rustc: /home/n/sandbox/3p/rust/src/llvm/lib/VMCore/Instructions.cpp:1062: void llvm::StoreInst::AssertOK(): Assertion `getOperand(0)->getType() == cast<PointerType>(getOperand(1)->getType())->getElementType() && "Ptr must be a pointer to Val type!"' failed.
Aborted

$ rustc --version
rustc 0.5 (07edf90 2012-10-13 05:57:13 -0700)
host: x86_64-unknown-linux-gnu

Bug Labels:
A-codegen, I-ICE

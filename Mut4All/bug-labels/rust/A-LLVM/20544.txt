Issue Title:
ICE(?): LLVM ERROR: Broken module found, compilation aborted! · Issue #20544 · rust-lang/rust · GitHub

Rust Code:
#![feature(associated_types)]
#![feature(unboxed_closures)]
#![feature(default_type_params)]

use std::ops::Mul;

struct Fun<F: Fn(T) -> T, T>(F);

impl<F, T> Fn(T) -> T for Fun<F, T>
where 
    F: Fn(T) -> T {

    extern "rust-call" fn call(&self, (t,): (T,)) -> T {
        (self.0)(t)
    }
}

impl<T, F1, F2> Mul<Fun<F2, T>> for Fun<F1, T>
where 
    F1: Fn(T) -> T, 
    F2: Fn(T) -> T {

    type Output = Compose<Fun<F1, T>, Fun<F2, T>, T>;
    fn mul(self, rhs: Fun<F2, T>) -> Compose<Fun<F1, T>, Fun<F2, T>, T> {
        Compose{f1: self, f2: rhs}
    }
}


struct Compose<F1, F2, T> where F1: Fn(T) -> T, F2: Fn(T) -> T {
    f1: F1,
    f2: F2
}

impl<T, F1, F2> Fn(T) -> T for Compose<F1, F2, T> 
where
    F1: Fn(T) -> T,
    F2: Fn(T) -> T {

    extern "rust-call" fn call(&self, (t,): (T,)) -> T {
        (self.f1)((self.f2)(t))
    }
}

fn main() {
    let f1 = Fun(|i: int| i * 2);
    let f2 = Fun(|i: int| i - 1);
    let f3 = f1 * f2;
    println!("{}", f3(3));
}

Bug Labels:
A-LLVM, E-needs-test, I-ICE

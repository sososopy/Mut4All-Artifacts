Issue Title:
ICE: `Unexpected type for 'Single' constructor` · Issue #117100 · rust-lang/rust · GitHub

Rust Code:
fn enum_upvar() {
    type T = impl Copy;
    let foo: T = Some((1u32, 2u32));
    let x = move || match foo {
        Foo => (),
        Some((a, b)) => (),
    };
}

Version Information:
Command:
/home/matthias/.rustup/toolchains/master/bin/rustc -Zcrate-attr=feature(non_exhaustive_omitted_patterns_lint) -Wnon-exhaustive-omitted-patterns

Command:
/home/matthias/.rustup/toolchains/master/bin/rustc -Zcrate-attr=feature(non_exhaustive_omitted_patterns_lint) -Wnon-exhaustive-omitted-patterns

Bug Trace:
#![feature(type_alias_impl_trait)]
// check-pass

fn main() {
    type T = impl Copy;
    let foo: T = Some((1u32, 2u32));
    match foo {
        None => (),
        Some((a, b)) => (),
    }
}

fn upvar() {
    #[derive(Copy, Clone)]
    struct Foo((u32, u32));

    type T = impl Copy;
    let foo: T = Foo((1u32, 2u32));
    let x = move || {
        let Foo((a, b)) = foo;
    };
}

fn enum_upvar() {
    type T = impl Copy;
    let foo: T = Some((1u32, 2u32));
    let x = move || {
        match foo {
            Foo => (),
            Some((a, b)) => (),
        }
    };
}

fn r#struct() {
    #[derive(Copy, Clone)]
    struct Foo((u32, u32));

    type U = impl Copy;
    let foo: U = Foo((1u32, 2u32));
    let Foo((a, b)) = foo;
}

mod only_pattern {
    type T = impl Copy;

    fn foo(foo: T) {
        let (mut x, mut y) = foo;
        x = 42;
        y = "foo";
    }

    type U = impl Copy;

    fn bar(bar: Option<U>) {
        match bar {
            Some((mut x, mut y)) => {
                x = 42;
                y = "foo";
            }
            None => {}
        }
    }
}

mod only_pattern_rpit {
    #[allow(unconditional_recursion)]
    fn foo(b: bool) -> impl Copy {
        let (mut x, mut y) = foo(false);
        x = 42;
        y = "foo";
        if b {
            panic!()
        } else {
            foo(true)
        }
    }

    fn bar(b: bool) -> Option<impl Copy> {
        if b {
            return None;
        }
        match bar(!b) {
            Some((mut x, mut y)) => {
                x = 42;
                y = "foo";
            }
            None => {}
        }
        None
    }
}

Bug Labels:
A-exhaustiveness-checking, A-patterns, C-bug, I-ICE, T-compiler

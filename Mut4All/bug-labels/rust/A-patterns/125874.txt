Issue Title:
ICE: `Encountered unexpected type in ConstructorSet::for_ty` in `rustc_pattern_analysis/src/rustc.rs` · Issue #125874 · rust-lang/rust · GitHub

Rust Code:
pub trait A {}

pub trait Mirror {
    type Assoc: ?Sized;
}
impl<T: ?Sized> Mirror for dyn A {
    type Assoc = T;
}

struct Bar {
    foo: <dyn A + 'static as Mirror>::Assoc,
}

pub fn main() {
    let strct = Bar { foo: 3 };

    match strct {
        Bar { foo: 1, .. } => {}
        _ => (),
    };
}

Command:
rustc

Bug Trace:
pub trait A {}
pub trait B: A {}

pub trait Mirror {
    type Assoc: ?Sized;
}
impl<T: ?Sized> Mirror for A {
    type Assoc = T;
}

pub fn foo<'a>(x: &'a <dyn A + 'static as Mirror>::Assoc) -> &'a <dyn B + 'static as Mirror>::Assoc {
    static
}


//@ run-pass

#![feature(postfix_match)]

struct Bar {
    foo: <dyn A + 'static as Mirror>::Assoc,
    baz: u8,
}

pub fn main() {
    let thing = Some("thing");

    thing.match {
        Some("nothing") => {},
        Some(text) if text.eq_ignore_ascii_case("tapir")  => {},
        Some("true") | Some("false") => {},
        Some("thing") => {},
        Some(_) => {},
        None => {}
    };

    let num = 2u8;

    num.match {
        0 => {},
        1..=5 => {},
        _ => {},
    };

    let slic = &[1, 2, 3, 4][..];

    slic.match {
        [1] => {},
        [2, _tail @ ..] => {},
        [1, _] => {},
        _ => {},
    };

    slic[0].match {
        1 => 0,
        i => i,
    };

    let out = (1, 2).match {
        (1, 3) => 0,
        (_, 1) => 0,
        (1, i) => i,
        _ => 3,
    };
    assert!(out == 2);

    let strct = Bar {
        foo: 3,
        baz: 4
    };

    strct.match {
        Bar { foo: 1, .. } => {},
        Bar { baz: 2, .. } => {},
        _ => (),
    };
}

Bug Labels:
A-patterns, C-bug, I-ICE, S-bug-has-test, S-has-mcve, T-compiler
